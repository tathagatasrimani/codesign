{
  "symbolic_expressions": {
    "R_decoder_stage": {
      "expression": "R_eff*V_dd/(I_on*W)",
      "latex": "\\frac{R_{eff} V_{dd}}{I_{on} W}",
      "symbols": [
        "W",
        "R_eff",
        "I_on",
        "V_dd"
      ]
    },
    "C_decoder_stage": {
      "expression": "C_gate + C_wire",
      "latex": "C_{gate} + C_{wire}",
      "symbols": [
        "C_gate",
        "C_wire"
      ]
    },
    "t_decoder_stage": {
      "expression": "R_eff*V_dd*(C_gate + C_wire)/(I_on*W)",
      "latex": "\\frac{R_{eff} V_{dd} \\left(C_{gate} + C_{wire}\\right)}{I_{on} W}",
      "symbols": [
        "C_gate",
        "R_eff",
        "V_dd",
        "W",
        "C_wire",
        "I_on"
      ]
    },
    "R_bitline": {
      "expression": "R_per_cell*rows",
      "latex": "R_{per cell} rows",
      "symbols": [
        "R_per_cell",
        "rows"
      ]
    },
    "C_bitline": {
      "expression": "C_per_cell*rows",
      "latex": "C_{per cell} rows",
      "symbols": [
        "rows",
        "C_per_cell"
      ]
    },
    "tau_bitline": {
      "expression": "R_per_cell*rows*(C_mux + C_per_cell*rows/2) + (R_access + R_pulldown)*(C_access + C_mux + C_per_cell*rows)",
      "latex": "R_{per cell} rows \\left(C_{mux} + \\frac{C_{per cell} rows}{2}\\right) + \\left(R_{access} + R_{pulldown}\\right) \\left(C_{access} + C_{mux} + C_{per cell} rows\\right)",
      "symbols": [
        "C_access",
        "R_access",
        "R_pulldown",
        "C_mux",
        "C_per_cell",
        "R_per_cell",
        "rows"
      ]
    },
    "tau_bitline_with_log": {
      "expression": "(R_per_cell*rows*(C_mux + C_per_cell*rows/2) + (R_access + R_pulldown)*(C_access + C_mux + C_per_cell*rows))*log(V_precharge/(V_precharge - V_sense/2))",
      "latex": "\\left(R_{per cell} rows \\left(C_{mux} + \\frac{C_{per cell} rows}{2}\\right) + \\left(R_{access} + R_{pulldown}\\right) \\left(C_{access} + C_{mux} + C_{per cell} rows\\right)\\right) \\log{\\left(\\frac{V_{precharge}}{V_{precharge} - \\frac{V_{sense}}{2}} \\right)}",
      "symbols": [
        "V_precharge",
        "C_access",
        "R_access",
        "R_pulldown",
        "V_sense",
        "C_mux",
        "C_per_cell",
        "R_per_cell",
        "rows"
      ]
    },
    "tau_bitline_expanded": {
      "expression": "R_per_cell*rows*(2*C_mux + C_per_cell*rows)/2 + (R_access + R_pulldown)*(C_access + C_mux + C_per_cell*rows)",
      "latex": "\\frac{R_{per cell} rows \\left(2 C_{mux} + C_{per cell} rows\\right)}{2} + \\left(R_{access} + R_{pulldown}\\right) \\left(C_{access} + C_{mux} + C_{per cell} rows\\right)",
      "symbols": [
        "C_access",
        "R_access",
        "R_pulldown",
        "C_mux",
        "C_per_cell",
        "R_per_cell",
        "rows"
      ]
    },
    "t_senseamp": {
      "expression": "C_load*V_swing/I_amp",
      "latex": "\\frac{C_{load} V_{swing}}{I_{amp}}",
      "symbols": [
        "C_load",
        "V_swing",
        "I_amp"
      ]
    },
    "R_mux_pass": {
      "expression": "R_eff*V_dd/(I_on*W_pass)",
      "latex": "\\frac{R_{eff} V_{dd}}{I_{on} W_{pass}}",
      "symbols": [
        "R_eff",
        "I_on",
        "V_dd",
        "W_pass"
      ]
    },
    "t_mux_level": {
      "expression": "C_load*R_eff*V_dd/(I_on*W_pass)",
      "latex": "\\frac{C_{load} R_{eff} V_{dd}}{I_{on} W_{pass}}",
      "symbols": [
        "V_dd",
        "R_eff",
        "C_load",
        "I_on",
        "W_pass"
      ]
    },
    "t_total_symbolic": {
      "expression": "C_load*V_swing/I_amp + t_bitline + t_decoder + t_mux",
      "latex": "\\frac{C_{load} V_{swing}}{I_{amp}} + t_{bitline} + t_{decoder} + t_{mux}",
      "symbols": [
        "t_mux",
        "V_swing",
        "t_bitline",
        "C_load",
        "I_amp",
        "t_decoder"
      ]
    }
  },
  "calibrated_values": {
    "t_decoder": 1.2e-09,
    "t_bitline": 1.99e-09,
    "t_senseamp": 6.754999999999999e-12,
    "t_mux": 2.4213e-11,
    "t_total": 3.220968e-09
  },
  "config_params": {
    "rows": 1024,
    "cols": 2048,
    "num_banks_x": 1,
    "num_banks_y": 1,
    "num_stacks": 2,
    "senseamp_mux": 1,
    "output_mux_l1": 1,
    "output_mux_l2": 8
  },
  "calibration_info": {
    "source": "C++ DESTINY",
    "note": "Calibrated values match C++ DESTINY exactly",
    "usage": "Use calibrated_values for design, symbolic for analysis"
  }
}